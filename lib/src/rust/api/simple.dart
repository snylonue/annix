// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.24.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../player.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:uuid/uuid.dart';

Future<void> updateNetworkStatus({required bool isOnline, dynamic hint}) =>
    RustLib.instance.api.updateNetworkStatus(isOnline: isOnline, hint: hint);

String greet({required String name, dynamic hint}) =>
    RustLib.instance.api.greet(name: name, hint: hint);

// Rust type: RustOpaqueMoi<LocalStoreConnection>
@sealed
class LocalStoreConnection extends RustOpaque {
  LocalStoreConnection.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  LocalStoreConnection.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib
        .instance.api.rust_arc_increment_strong_count_LocalStoreConnection,
    rustArcDecrementStrongCount: RustLib
        .instance.api.rust_arc_decrement_strong_count_LocalStoreConnection,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_LocalStoreConnectionPtr,
  );
}

// Rust type: RustOpaqueMoi<Mutex < RepoDatabaseRead >>
@sealed
class MutexRepoDatabaseRead extends RustOpaque {
  MutexRepoDatabaseRead.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  MutexRepoDatabaseRead.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib
        .instance.api.rust_arc_increment_strong_count_MutexRepoDatabaseRead,
    rustArcDecrementStrongCount: RustLib
        .instance.api.rust_arc_decrement_strong_count_MutexRepoDatabaseRead,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_MutexRepoDatabaseReadPtr,
  );
}

// Rust type: RustOpaqueMoi<Player>
@sealed
class Player extends RustOpaque {
  Player.dcoDecode(List<dynamic> wire) : super.dcoDecode(wire, _kStaticData);

  Player.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Player,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Player,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_PlayerPtr,
  );
}

// Rust type: RustOpaqueMoi<StreamWrapper < PlayerStateEvent >>
@sealed
class StreamWrapperPlayerStateEvent extends RustOpaque {
  StreamWrapperPlayerStateEvent.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  StreamWrapperPlayerStateEvent.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib.instance.api
        .rust_arc_increment_strong_count_StreamWrapperPlayerStateEvent,
    rustArcDecrementStrongCount: RustLib.instance.api
        .rust_arc_decrement_strong_count_StreamWrapperPlayerStateEvent,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_StreamWrapperPlayerStateEventPtr,
  );
}

// Rust type: RustOpaqueMoi<StreamWrapper < ProgressState >>
@sealed
class StreamWrapperProgressState extends RustOpaque {
  StreamWrapperProgressState.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  StreamWrapperProgressState.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib.instance.api
        .rust_arc_increment_strong_count_StreamWrapperProgressState,
    rustArcDecrementStrongCount: RustLib.instance.api
        .rust_arc_decrement_strong_count_StreamWrapperProgressState,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_StreamWrapperProgressStatePtr,
  );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::rust_async::RwLock<Mutex < Connection >>>
@sealed
class MutexConnection extends RustOpaque {
  MutexConnection.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  MutexConnection.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_MutexConnection,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_MutexConnection,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_MutexConnectionPtr,
  );
}

class AnnixPlayer {
  final Player player;
  final StreamWrapperPlayerStateEvent state;
  final StreamWrapperProgressState progress;

  const AnnixPlayer({
    required this.player,
    required this.state,
    required this.progress,
  });

  bool isPlaying({dynamic hint}) => RustLib.instance.api.annixPlayerIsPlaying(
        that: this,
      );

  static AnnixPlayer newAnnixPlayer({dynamic hint}) =>
      RustLib.instance.api.annixPlayerNew(hint: hint);

  Future<void> openFile({required String path, dynamic hint}) =>
      RustLib.instance.api.annixPlayerOpenFile(
        that: this,
        path: path,
      );

  Future<void> pause({dynamic hint}) => RustLib.instance.api.annixPlayerPause(
        that: this,
      );

  Future<void> play({dynamic hint}) => RustLib.instance.api.annixPlayerPlay(
        that: this,
      );

  Stream<PlayerStateEvent> playerStateStream({dynamic hint}) =>
      RustLib.instance.api.annixPlayerPlayerStateStream(
        that: this,
      );

  Stream<ProgressState> progressStream({dynamic hint}) =>
      RustLib.instance.api.annixPlayerProgressStream(
        that: this,
      );

  Future<void> seek({required int position, dynamic hint}) =>
      RustLib.instance.api.annixPlayerSeek(
        that: this,
        position: position,
      );

  Future<void> setVolume({required double volume, dynamic hint}) =>
      RustLib.instance.api.annixPlayerSetVolume(
        that: this,
        volume: volume,
      );

  Future<void> stop({dynamic hint}) => RustLib.instance.api.annixPlayerStop(
        that: this,
      );

  @override
  int get hashCode => player.hashCode ^ state.hashCode ^ progress.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AnnixPlayer &&
          runtimeType == other.runtimeType &&
          player == other.player &&
          state == other.state &&
          progress == other.progress;
}

/// Repo
class LocalDb {
  final MutexRepoDatabaseRead repo;

  const LocalDb({
    required this.repo,
  });

  Future<String?> getAlbum({required UuidValue albumId, dynamic hint}) =>
      RustLib.instance.api.localDbGetAlbum(
        that: this,
        albumId: albumId,
      );

  Future<List<UuidValue>> getAlbumsByTag(
          {required String tag, required bool recursive, dynamic hint}) =>
      RustLib.instance.api.localDbGetAlbumsByTag(
        that: this,
        tag: tag,
        recursive: recursive,
      );

  Future<List<TagItem>> getTags({dynamic hint}) =>
      RustLib.instance.api.localDbGetTags(
        that: this,
      );

  static Future<LocalDb> newLocalDb({required String path, dynamic hint}) =>
      RustLib.instance.api.localDbNew(path: path, hint: hint);

  @override
  int get hashCode => repo.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LocalDb &&
          runtimeType == other.runtimeType &&
          repo == other.repo;
}

class LocalStore {
  final LocalStoreConnection conn;

  const LocalStore({
    required this.conn,
  });

  Future<void> clear({String? category, dynamic hint}) =>
      RustLib.instance.api.localStoreClear(
        that: this,
        category: category,
      );

  Future<String?> get(
          {required String category, required String key, dynamic hint}) =>
      RustLib.instance.api.localStoreGet(
        that: this,
        category: category,
        key: key,
      );

  Future<void> insert(
          {required String category,
          required String key,
          required String value,
          dynamic hint}) =>
      RustLib.instance.api.localStoreInsert(
        that: this,
        category: category,
        key: key,
        value: value,
      );

  static LocalStore newLocalStore({required String root, dynamic hint}) =>
      RustLib.instance.api.localStoreNew(root: root, hint: hint);

  @override
  int get hashCode => conn.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LocalStore &&
          runtimeType == other.runtimeType &&
          conn == other.conn;
}

/// Preferences
class NativePreferenceStore {
  final MutexConnection conn;

  const NativePreferenceStore({
    required this.conn,
  });

  String? get({required String key, dynamic hint}) =>
      RustLib.instance.api.nativePreferenceStoreGet(
        that: this,
        key: key,
      );

  static NativePreferenceStore newNativePreferenceStore(
          {required String root, dynamic hint}) =>
      RustLib.instance.api.nativePreferenceStoreNew(root: root, hint: hint);

  void remove({required String key, dynamic hint}) =>
      RustLib.instance.api.nativePreferenceStoreRemove(
        that: this,
        key: key,
      );

  void removePrefix({required String prefix, dynamic hint}) =>
      RustLib.instance.api.nativePreferenceStoreRemovePrefix(
        that: this,
        prefix: prefix,
      );

  void set({required String key, required String value, dynamic hint}) =>
      RustLib.instance.api.nativePreferenceStoreSet(
        that: this,
        key: key,
        value: value,
      );

  @override
  int get hashCode => conn.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NativePreferenceStore &&
          runtimeType == other.runtimeType &&
          conn == other.conn;
}

enum NetworkStatus {
  online,
  offline,
}

class ProgressState {
  final int position;
  final int duration;

  const ProgressState({
    required this.position,
    required this.duration,
  });

  @override
  int get hashCode => position.hashCode ^ duration.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ProgressState &&
          runtimeType == other.runtimeType &&
          position == other.position &&
          duration == other.duration;
}

class TagItem {
  final String name;
  final List<String> children;

  const TagItem({
    required this.name,
    required this.children,
  });

  @override
  int get hashCode => name.hashCode ^ children.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TagItem &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          children == other.children;
}
